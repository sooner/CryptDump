\section{Introduction to Cryptdb}

This section introduces the structure of Cryptdb to show how data is duplicated. This introduction is based on the cryptdb paper\citep{popa2011cryptdb} and the newest verion of Cryptdb implementation at \citep{cryptdbsite}. We would like to introduce the following content.



\begin{itemize}
\item[--] The overall structure of cryptdb and the related system
\item[--] The logical view of a table in cryptdb
\item[--] Structure of the encryption metadata
\end{itemize}

This section intends to give you insight on how we find duplicates in Cryptdb, and important issues to consider when designing a backup system for cryptdb. Also, some important terms in cryptdb will be explain.

\subsection{Structure of Cryptdb}

In the cryptdb system, there are three components: client, server, and proxy. The Client is usually a webserver, and the server has MySQL  or other DBMS installed. In our current environment, we use MySQL5.7 as DBMS and MySQL-Proxy0.8.5 as proxy. The client communicate with the proxy instead of communicating directly with the server. The MySQL server is not trusted while the Proxy is trusted. When the client receive DDL queries, it will stored related encryption metadata to describe the encryption scheme of each table. For both DML and DDL queries, the proxy perform query rewrite to encrypt the query and send encrypted query to MySQL server. The results are sent to the proxy first for decryption, and then plain text will be sent to client. Figure~\ref{fig:stack1} shows the four steps of executing a SQL query in a system using Cryptdb and the two steps of executing SQL queries in a system using normal database system.



\begin{figure}[tb]
\centering
\includegraphics[width=6cm]{images/Cryptdb-structure.pdf}
\caption{structure of cryptdb}
\label{fig:stack1}
\end{figure}



\subsection{data layout and structure}

In this section, we talk about the onion encryption model and how an original plaintext table is expanded. Since there are currently only two data type supported in cryptdb, we will use an example table with those two data types: String and Integer. Figure~\ref{fig:stackx} shows how the data columns of the original plain text table are extended. For integer type, one original column is replicated for three times and encrypted using three differnt onions, the forth column IV is 64bits random integer used for encryption and decryption of the replicated columns. The column of Integer type is also replicated three times. And IV is used for the same purpose. Each of the replicated column is called an onion column. The onion is binded with several encryption layers, and each layer has it's own encryption key. The name of the onion columns indicates the onion's function: Onion DET support equal comparison; Onion OPE has the properity of order preserving; Onion Search allow searching on cipher text ; Onion HOM allow addation on ciphertext. So the queries for the web server against the columns on the original table is transformed into queries against the encrypted onion columns. If we want equal comparison, we can use the onion DET. If we need order comparison like order by, we can use the onion OPE. So different onion support different operation on the ciphertext. 




\begin{figure}[tb]
\centering
\includegraphics[width=6cm]{images/extend.pdf}
\caption{Extended table}
\label{fig:stackx}
\end{figure}

For security purposes, each onion also have two or more layers. Figure~\ref{fig:stack2}(a) provides illustration of the onions for string, and Figure~\ref{fig:stack2}(b) shows the layout of the onions for integer type. We can find that in each onion, the original plain text is encrypted several times through layers of encryption. For example, onion O-DET-STR has three layers. Suppose that the plaintext is 'p1', and it is first encrypted using AES\_CMC, and we get the ciphertext 'c1'. Then in the second layer DET\_STR, 'c1' is used as input and we still use AES\_CMC for encryption, the result is 'c2'. Finally in the RND\_STR layer, AES\_CBC is used, and we get the final result 'c3'. It should be noted that random IV is used for encryption in the RND layer. So for this O-DET-STR column, two identical values are still the same in the first two layers, However, they are different when they reach the third layer because IV is used together with encryption key for encryption in this layer. Since each row in the table has thier own random IV for each field, the ciphertext for identical plaintext may not be identical. 

Different layers of one onion provide different level of security and also different function. The layer RND is random, so it can not provide any function. The layer DET-STR allow equal comparison, and the layer DET-JOIN-STR allow equal join operation between two tables. It should be noted that the onion DET only support equal comparison operation, and no layer of this onion can support order comparison or other functions. So in summary, each onion support one kind of operation, and each level of the onion reveal different level of that ability.





\begin{figure}[tb]
\centering
\includegraphics[width=8cm]{images/Onions.pdf}
\caption{Onion encryption layers for integer type}
\label{fig:stack2}
\end{figure}


\subsection{metadata layout and structure}

This section talks about metadata layout. Metadata is stroed in the proxy. It records the encryption details of the table in the DBMS. For example, we can read and parse the metadata to find how many databases are created. For each database, we can find how many table are in it. For each table, we can find how many fields it has, and for each field, the detailed information of the onions and layers are recorded. Those information will impact how we make choices when we bakcup data. The metadata form a hirechy from the database level to the encryption layer level. It has a structure of a tree, and is encoded and stored in a relational table. The amount of metadata is related only to the number tables and the number of fields in those tables, so the storage size is relatively small.

% Figure~\ref{fig:stack2} shows the structure of onionmeta. This is the information we need for logical deduplication. 



% \begin{figure}[tb]
% \centering
% \includegraphics[width=4cm]{images/layers.png}
% \caption{Onionmeta layout}
% \label{fig:stack3}
% \end{figure}


% Every node in the tree is storaed as a record with a unique id in a relational table. The relation among nodes and the content of a node is also stored in the same table. Each onion represents an encryption scheme, which has many layers. This tree structure can be stored in a simple relational table, 

% % CREATE TABLE MetaObject(id bigint(20) unsigned auto\_increment, parent\_id bigint(20),serial\_key varbinary(500),serial\_object varbinary(500));  


% So the metadata of databases, tables, fields, onions, layers are all serialized and stored in the proxy. 

% Since the amount of data is related only to the number tables and the number of fields in those tables, the storage size is small. Also, metadata is needed for decryption and data recovery, so we use physical backup and do not deduplicate the metadata. Metadata is in the form is plaintext, so traditional deduplication techinques can work properly.

