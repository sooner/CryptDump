\section{Space Overhead of Backup}

CryptDB creates multiple onions for each data item in DBMSes to support different kinds of computations. These onions of decryption trade several times of space in DBMSes for security and performance. However, for backup and recovery, there is no SQL queries and computations execute on these backup data. Multiple onions actually carry redundant information from the perspective of backup. We only need backup \textit{some} onions for each data item while maintaining their functionality and reducing space overhead. 
% As a result, we need to figure out \textit{how to find the best onion to backup and recover}.  
% The onion 'search' for string is not yet implemented in the newest version of CryptDB, so for this onion, our analysis is based on the description in \citep{song2000practical}.

CryptDB currently only supports two data types with three encryption schemes for each: string(DET, OPE, SEARCH) and integer(DET, OPE, HOM). We will analysis space overhead of each encryption scheme separately and present the findings in the end.

\subsection{DET}
DET is the only scheme supports both string and integer and also store the complete information of data items for backup and recovery. Onion DET has three layers, namely DET-JOIN, DET, and DET-RND. 

\textbf{Integer}. DET for integer uses algorithm named blowfish. The size of the ciphertext is always 64 bits. Therefore, the space overhead is constant.

\textbf{String}. DET for string is not the same esay as integer. To figure out the relationship between the size of plaintext and the size of ciphertext of different layers of DET, we encrypt two plain texts of 10 bytes and 1000 bytes. As illustrated in figure~\ref{fig:side:a},  for the 10 bytes text, the size of ciphertext of DET-JOIN, DET, DET-RND are 16 bytes, 32 bytes, and 48 bytes accordingly. For the 1000 bytes text, the size are 1008 bytes, 1024 bytes and 1048 bytes accordingly. It is straightforward to find out that the size difference among different ciphertexts is the same. They are all 16 bytes. The only special case is between plain text and ciphertext of DET-JOIN. We analysis the algorithms of DET and realize that the first two layers of DET uses AES-CMC for encryption, and the third layer uses AES\_CBC. These three algorithms all execute on blocks, which is now 16 bytes in the implementation of CryptDB. If the input text of the algorithm can not be divided exactly by the block size, the input will be padded with zero to make it divisible. If the input text is divisible, CryptDB will pad the text by one block. 

\textbf{Finding 1:} \textit{The space overhead of DET for integer keeps constant regardless of the size of plaintext;}

\textbf{Finding 2:} \textit{No matter how large is the size of plaintext, the size of ciphertext of each layer takes the min-max value which is divisible by 16.}

\subsection{HOM}
HOM only supports integer and uses algorithm named pailliar. Like DET for integer, the size of ciphertext of HOM is always 256 bytes, which introduces great space overhead to the system. Take the new\_orders table in TPC-C benchmark for example, it has three columns of integer type: int(4 Bytes), tinyint(1 Byte), smallint(2 Bytes). The original table owns 9,000 rows of data and takes 88 KB. After encrypted by HOM, the table increases to 8.5 MB, which are two orders of magnitude larger than the original one.

\textbf{Finding 3:} \textit{The ciphertext of HOM is always 256 bytes and space overhead linear correlated with the number of rows of the table.}

\subsection{OPE}
OPE requires that the cipher text size is double the size of plain text. 

\textbf{Integer}. Onion OPE-INT has three layers, namely OPE-INT-JION,OPE-INT,OPE-RND. If the plaintext is of the type tinyint, which has only 1 Bytes. Then after the layer OPE-INT-JOIN, it becomes 2 Bytes, and after the layer OPE-INT, it becomes 4 Bytes. So for the layer OPE-RND, the input is a 4 Bytes long integer, and the result of OPE-RND can be represented by a 8 Bytes big integer. If the size of the integer is 64 bits, then after the encryption of one layer of OPE, the ciphertext should be 128 bits, which can not fit in an integer type. CryptDB uses 128 bits varbinary data type. In that case, the input of the layer RND is string instead of integer, and they will use AES algorithms instead of blowfish. So the onion OPE-INT may contain layer RND-STR.

\textbf{String}. Onion OPE-STR also has three layers, OPE-STR-JOIN, OPE-STR, OPE-RND. When the input of the algorithm is a string, plaintext length of 4 Bytes and  ciphertext length of 8 Bytes are specified. That is, only the prefix are encrypted and has the properity of order preserving. Then in the layer OPE-STR, since in the first layer, the data type has been transformed to 64bits integer, the OPE-STR is transformed to OPE-INT, and the input is 64bits long. So after this layer, integer can no longer fit ciphertext. The data type has become 128 bits varbinary type. And then in the third layer, AES is used for the layer, adding one block to the size, making the total size of the onion 32 Bytes.



% In CryptDB, each column in a table can be encrypted into several onions. Each onion can have several layers. We have to make a choice whether to remove or retain a onion. If one column has three onions, we will have eight choices.  For each onion, we can either choose to backup it directly, or to decrypt some layers and then backup it. We will discuss whether those choices are practical.


% \begin{figure}%[tb]
% % \centering
% %\begin{tabular}{cc}
% \begin{minipage}[t]{0.48\linewidth}
% \centering
%   \includegraphics[width=4.0cm]{images/onions-for-string.eps}
%   % \centerline{(a) Result 1}
% \end{minipage}
% % \hfill

% \begin{minipage}[t]{0.48\linewidth}
% \centering
%   \includegraphics[width=4.0cm]{images/onion-for-integer.eps}
%   % \centerline{(b) Result 2}
% \end{minipage}
% % \vfill

% %\end{tabular}
% \caption{Example of placing a figure with experimental results.}
% \label{fig:res}

% % \includegraphics[width=\columnwidth]{images/onions-for-string.eps}
% % \caption{onions-for-string}
% % \label{fig:stack4}
% \end{figure}


% \begin{figure}   
%   \begin{minipage}[t]{0.5\linewidth}  
%     \centering   
%     \includegraphics[width=4.0cm]{images/onions-for-string.eps}   
%     \caption{onions-for-string}   
%     \label{fig:side:a}   
%   \end{minipage}%   
%   \begin{minipage}[t]{0.5\linewidth}   
%     \centering   
%     \includegraphics[width=4.0cm]{images/onion-for-integer.eps}   
%     \caption{onion-for-integer}   
%     \label{fig:side:b}   
%   \end{minipage}   
% \end{figure}


% \begin{table}
% \renewcommand{\arraystretch}{1.3}
% \caption{Simple table}
% \label{tab:example}
% \centering
% \begin{tabular}{|c|c|c|c|}
%   \hline
%   % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
% &t & customer & district \\
% DET & 1 & 1\\  
%  &  & \\
% HOM & 1 & 1\\
% IV & 1 & 1  \\
% \hline
% \end{tabular}
% \end{table}

\begin{table}
\renewcommand{\arraystretch}{1.3}
\caption{Simple table}
\label{tab:exampless}
\begin{tabular}{p{0.8cm}|p{0.8cm}p{0.8cm}|p{0.8cm}p{0.8cm}|p{0.8cm}p{0.8cm}}%
\toprule
\multirow{2}{2cm}{Layers} & \multicolumn{2}{c}{\textbf{Onion-DET}} & \multicolumn{2}{c}{\textbf{Onion-OPE}} & \multicolumn{2}{c}{\textbf{Onion-HOM}}\\
\cmidrule{2-7}
& Integer & String & Integer & String & Integer & String\\
\midrule
Plain & 4B & 10B & 4B & 10B & 4B & null \\
Layer1 & 8B & 16B & 8B & 8B & 256B & null \\
Layer2 & 8B & 32B & 16B & 16B & null & null \\
Layer3 & 8B & 48B & 32B & 32B & null & null \\
\bottomrule
\end{tabular}
\end{table}






% \begin{figure}[tb]
% \centering
% \includegraphics[width=8cm]{images/onion-for-integer.eps}
% \caption{onions-for-integer}
% \label{fig:stack6}
% \end{figure}




% \begin{figure}[tb]
% \centering
% \includegraphics[width=\columnwidth]{images/det_str.eps}
% \caption{det-str-eps}
% \label{fig:stack5}
% \end{figure}



% Figure~\ref{fig:stack4},~\ref{fig:stack5} shows how the size of a string change for each onion and each layer of the onions. As the figure depicts, for the onion DET, the plain text is 10 Bytes long, while the size of the onion in layer RND is 48 Bytes long. That because the onion DET has three layers, namely DET-JOIN, DET, and DET-RND. The first two layers uses AES-CMC for encryption, and the third layer uses AES\_CBC. In the current implementation, block size of 16 bytes is uses. In current version of CryptDB, the input text of the algorithm can not be divided exactly by the block size, then the input should be padded with zero to make it divisible. If the input text is divisible, cryptdb will pad the text by one block. So, for plain text with size 10 Bytes, after it is encrypted with layer DET-JOIN, it becomes 16 Bytes. After it is encrypted with layer DET, it is padded to 32 Bytes. And when it is in layers DET-RND, the size becomes 48 Bytes. Note that for ciphertext, CryptDB used only the integer type of MySQL if the size of ciphertext can fit in that data type. Otherwise, varbinary is used instead. Since Onion Search is not implemented properly, we do not include it in the figure. In fact, the onion search is quiet simple: it has only two layers, and according to \citep{song2000practical}, the size of ciphertext is roughly the same as plaintext. In the current implementation, the change of data type and size of OPE is quiet complex. In fact, the Onion OPE only guarantee the properity of order preserving for 8 bytes prefix of a string.






% Figure~\ref{fig:stack6} shows how the storage size change for each onion for integer type. Currently, there are three onions for integer, HOM uses Pailliar algorithm, DET for integer uses 64bits blowfish, so the size of the ciphertext is always 64bits integer. There is no padding. HOM uses pailliar, so the result is always 256bytes integer. MySQL do not has such long integer, so varbinary(256) is used instead. Now let's discussion how the size change across layers of the onion OPE for both String type and Integer type. 



% OPE requires that the cipher text size is double the size of plain text. Let's first discuss OPE-INT. This onion has three layers, namely OPE-INT-JION,OPE-INT,OPE-RND. If the plaintext is of the type tinyint, which has only 1 Bytes. Then after the layer OPE-INT-JOIN, it becomes 2 Bytes, and after the layer OPE-INT, it becomes 4 Bytes. So for the layer OPE-RND, the input is a 4 Bytes long integer, and the result of OPE-RND can be represented by a 8 Bytes bigint in MySQL. If the size of the integer is 64 bits, then after the encryption of one layer of OPE, the ciphertext should be 128 bits, which can not fit in an integer type. Cryptdb uses 128 bits varbinary data type. In that case, the input of the layer rnd is string instead of integer, so algorithm AES is used instead of blowfish. So the onion OPE-INT may contain layer RND-STR. 

% Then let's talk about OPE-STR. OPE-STR can also have three layers, OPE-STR-JOIN, OPE-STR, OPE-RND. When the input of the algorithm is a string, plaintext length of 4 Bytes and  ciphertext length of 8 Bytes are specified. That is, only the prefix are encrypted and has the properity of order preserving. Then in the layer OPE-STR, since in the first layer, the data type has been transformed to 64bits integer, the OPE-STR is transformed to OPE-INT, and the input is 64bits long. So after this layer, integer can no longer fit ciphertext. The data type has become 128 bits varbinary type. And then in the third layer, aes is used for the layer, adding one block to the size, making the total size of the onion 32 Bytes.


\textbf{Finding 4:} \textit{The size of onion OPE can not exceed 32 Bytes regardless of the size of plaintext};

\textbf{Finding 5:} \textit{Onion OPE can lose information of the plaintext, so we can not use the Onion OPE for backup and recovery}.

\subsection{SEARCH}
SEARCH is quiet simple: it has only two layers. According to \citep{song2000practical}, the size of ciphertext is roughly the same as plaintext.

\section{Computation Overhead of Recovery}
As we have known the property of the encryption schemes and the data layout. We can now start to design the strategy of deduplication. We will first discuss each onion and then give three simple strategies for analysis. Then in the experiment section, we will use our workload to test the strategies. We first discuss the design choices for each onion of integer data and string data. 


\begin{itemize}
\item Integer/String OPE: For ope-int, we have little choices, since OPE is not able to be decrypted. If this onion is removed, then we need two OPE-Encrypt operation and one AES-enctypt operation to get it back. 
\item Integer HOM: HOM takes a long time to recover, and also occupy 256 Bytes. If we choose to remove it, we should use one Paillar-encrypt operation to get it back. Only retaining HOM is never a good choice, because it takes a long time to decrypt HOM for recovery, and also the storage size is large. So HOM should be removed or be retained together with other onions.
\item Integer/String DET: If this onion is removed, then it takes three blowfish-encrypt operations to recover it. For String type, we need two AES-CMC-encrypt and one AES-CBC-encrypt operation to recover the onion. The encryption time is related to the size of the string.
\item Integer IV: 8Bytes integer. faster to regenerate
\end{itemize}


\section{Strategies for Deduplication}
Since the detailed performance is related to so many things, we do not provide exact strategy for backup. Instead, we summarize several Principals for cryptdb backup and then give some examples. 

\begin{itemize}
\item If you want minimum storage overhead, you should find the onion with the least size for each column, like AES or blowfish, that can produce ciphertext of the size similar to plaintext, and remove all the other onions. 
\item If you want minimum time overhead, you should backup all the onions, so that you can recover the data directly.
\item Metadata should have a full backup for data recovery, and the size of metadata is small. 
\item For recovery, we need to decrypt the onion we have, and based on the metadata, recompute the ciphertext for other onions.
\item For one onion, we can choose the stay in RND layers, which means identical plaintext can have different ciphertext. If we decypt it to a layer that is not random, then identical plaintext can have the same ciphertext. If most of the plain text in this column are the same, then it will be easy to compress this filed to reduce storage overhead. Also, if we decrypt RND layer, then we can remove the IV column, which further reduces storage overhead.
\end{itemize}


Based on these principals, we propose following suggestions for backup and recovery on CryptDB. 

\begin{itemize}
\item Remove RND and use DET onion will produce the least storage overhead.
\item Do not remove anything. This is the strategy with the most storage over head and least computation overhead
\item Retain RND and salt for DET, remove HOM and OPE, and Search. This method has high security level.
\end{itemize}

For those two data types and strategy, we construct microbenchmark to do experiments. Actually, the time needed for recovery can be reduced by using multi-threading or other optimization. We assumes that other factors are the same and only consider the overhead of recomputation. We use single thread with pipeline insert.

% The overall strategy looks like: we let users choose the strategy base on what they care about. They can either choose to backup all the onions, or choose to have minimum backup or something in between. Figure~\ref{fig:stack7} shows how to encrypt and extend the plain text, and then choose one onion for back up, and then compress the onion. For recovery, we should first decrypt the onions and then recompute the deleted onion. Then we should be able to construct the sql queries for recovery. This is the same as the logical backup recovery method.

\begin{figure}[tb]
\centering
\includegraphics[width=8cm]{images/backup_and_recovery.pdf}
\caption{backup\_and\_recovery.pdf}
\label{fig:stack7}
\end{figure}



